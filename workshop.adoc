= Implementing the API Gateway pattern with GraphQL
Vladimir Dejanovic <https://twitter.com/vladimird_42[@vladimird_42]>; Thomas Segismont <https://twitter.com/tsegismont[@tsegismont]>
:toc: left
:toclevels: 3
:source-highlighter: rouge

== Introduction

=== Microservices architecture

In a https://microservices.io/patterns/microservices.html[microservices architecture], several loosely coupled, independently deployable services comprise a large software application.

This type of design can provide quite a few benefits, including:

* ability to release more often and more reliably
* codebases easier to reason about
* independence to a particular technology

For example, an online store application could be composed of, among others, an inventory and a rating service:

[graphviz, microservices-architecture, svg]
.Online store application, microservices architecture
----
strict digraph {
    rankdir=LR;
    splines="line";
    client [label="Client" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    inventory [label="Inventory service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    rating [label="Rating service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    inventorydb [label="Inventory DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    ratingdb [label="Rating DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    client -> inventory
    client -> rating
    inventory -> inventorydb
    rating -> ratingdb
}
----

=== The API Gateway pattern

The client side of the application may have to contact several services to display a single screen or page.
For instance, to display a product details page, it needs product info from the inventory service and customer reviews from the rating service.

But each network communication comes with a cost.
This applies to desktop browsers with DSL or fiber links, but the impact is particularly significant on mobile networks.

This is one important reason why the _API Gateway_ pattern has emerged.
In practice, the client communicates with a single service, the gateway, which communicates with the backend services:

[graphviz, api-gateway-pattern, svg]
.API Gateway pattern
----
strict digraph {
    rankdir=LR;
    splines="line";
    client [label="Client" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    gateway [label="API Gateway" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    inventory [label="Inventory service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    rating [label="Rating service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    gatewaydb [label="Gateway DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    inventorydb [label="Inventory DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    ratingdb [label="Rating DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    client -> gateway
    gateway -> gatewaydb
    gateway -> rating
    gateway -> inventory
    inventory -> inventorydb
    rating -> ratingdb
    {rank = same; gateway; gatewaydb;}
}
----

[NOTE]
====
The API Gateway does not eliminate the coordination required to make sense of the backend data.
In fact, it adds a new network hop in the the sequence of service calls.

But it moves most of the interactions inside the datacenter, where network latencies are considerably better.
====

Very often, the API Gateway provides cross-cutting concerns like security.
For example, it could generate a token after authenticating the client and communicate it to the backend services as a proof of identity.

It may also provide its own features, if they are only relevant to the frontend.
An e-commerce application, for instance, could manage customers' shopping carts at the API Gateway level.

From a performance standpoint, an event-driven implementation would give better results under load.
Indeed, the API Gateway's workload is dominated by I/O, so having threads blocked waiting is not an optimal usage of resources.

=== Serving many clients

A lot of applications nowadays must be available from a wide range of clients: browsers, smartphones, tablets, wearables... etc.
These clients all have different capabilities in terms of display and networking.

Let's consider the product details use case.
For a desktop user, it makes sense to show:

* the product info (inventory service)
* the average rating (rating service)
* users' reviews (rating service)

However, in a smartphone app the reviews would probably be accessible in a separate view because of the screen size and shape.

But if the mobile developer uses the same endpoint as the web developer, the API Gateway wastes:

* time (_latency_) waiting for rating service responses, and
* bandwith sending a lot of unnecessary data.

To overcome this problem, it is possible to create a backend specific to each type of frontend.

[graphviz,backend-for-frontends,svg]
.Backend for Frontends pattern
----
strict digraph {
    rankdir=LR;
    splines="line";
    webclient [label="Web Client" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    mobileclient [label="Mobile Client" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    webgateway [label="Web Gateway" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    mobilegateway [label="Mobile Gateway" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    inventory [label="Inventory service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    rating [label="Rating service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    inventorydb [label="Inventory DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    ratingdb [label="Rating DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    webclient -> webgateway
    mobileclient -> mobilegateway
    webgateway -> rating
    webgateway -> inventory
    mobilegateway -> rating
    mobilegateway -> inventory
    inventory -> inventorydb
    rating -> ratingdb
    {rank = clients; mobileclient; webclient;}
    {rank = gateways; mobilegateway; webgateway;}
}
----

Nevertheless, this design, also known as the _Backend for Frontends_ pattern, has a few drawbacks:

* each specific API Gateway is another component to maintain
* a lot of code is duplicated
* each new feature has to be supported in all gateways before all clients can start using it

=== GraphQL in a nutshell

==== What it is

https://graphql.org/[GraphQL] is a query and schema definition language for your backend services.

It allows backend developers to describe the data in a language-agnostic fashion:

[source,graphql]
.GraphQL Schema file
----
type Genre {
  id: ID
  name: String!
}

type Album {
  id: ID
  name: String!
  genre: Genre!
  artist: String!
  reviews: [Review!]
}

type Review {
  name: String!
  rating: Int!
  comment: String
}

type Query {
  albums(genre: ID): [Album!]
}

schema {
  query: Query
}
----

And then frontend developers to request exactly the information they need:

[source,graphql]
.GraphQL query
----
query ($id: ID!) {
  album(id: $id) {
    id
    name
    genre {
      name
    }
    artist
  }
}
----

Which, given an `id` variable, would result in:

[source,json]
.GraphQL results
----
{
  "album": {
    "name": "Revolver",
    "genre": {
      "name": "Pop"
    },
    "artist": "The Beatles"
  }
}
----

While the https://graphql.github.io/graphql-spec/[GraphQL specification] does not prescribe any transport, in practice it's often used over HTTP and Websockets.

TIP: You will find a GraphQL schema definition and query authoring introduction on https://graphql.org/learn/.

==== How it works

When a GraphQL server runtime starts, it:

. parses the schema file to discover types and fields
. binds each field to data fetching functions

[graphviz,graphql-server-runtime,svg]
.GraphQL server runtime creation
----
strict digraph {
    splines="line";
    schema [label="Types and Fields" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    fetchers [label="Data Fetchers" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    runtime [label="GraphQL Runtime" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    schema -> runtime
    fetchers -> runtime
}
----

Then when a request is received, it:

. validates the query
. invokes each data fetching function needed to produce the result
. sends the result to the client

[graphviz,graphql-query-execution,svg]
.GraphQL query execution phases
----
strict digraph {
    rankdir=LR;
    splines="line";
    validation [label="Validation" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    execution [label="Execution" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    result [label="Result" shape="ellipse" color="#585858" style="filled" fillcolor="#782b90" fontcolor="white"]
    validation -> execution
    execution -> result
}
----

==== API Gateway engine

GraphQL becomes more and more popular, including as a replacement for _RESTful_ or HTTP/JSON APis.

But it particularly shines when building API Gateways.
Why?
Let's consider the product details use case again.

When the desktop client sends a request to the GraphQL runtime, it will ask for product info as well as users' review.
And the runtime will execute the corresponding data fetchers:

[source,graphql]
.Desktop client query
----
query ($id: ID!) {
  album(id: $id) {
    id
    name
    genre {
      name
    }
    artist
    reviews {
      name
      comment
      rating
    }
  }
}
----

However, the smartphone client will only ask for the product info:

[source,graphql]
.Smartphone client query
----
query ($id: ID!) {
  album(id: $id) {
    id
    name
    genre {
      name
    }
    artist
  }
}
----

And the runtime will **NOT** execute the data fetchers for customers' reviews and, obviously, will not send the unnecessary data.

== The MusicStore Application

The _MusicStore_ is an online music shop.
You can browse its catalog by genre, read customer reviews, see the list of tracks.
When logged-in, you may add albums to your cart, manage your cart items or post your own reviews.

Technically, it is comprised of the following components:

* the <<Web Client>>
* the API Gateway which:
** serves the static content
** runs the GraphQL runtime
** authenticates the customers
** records cart items
* the <<Inventory Service>>
* the <<Rating Service>>

[graphviz,musicstore-app,svg]
.The MusicStore application
----
strict digraph {
    rankdir=LR;
    splines="line";
    client [label="Web Client" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    gateway [label="API Gateway" shape="polygon" color="#782b90" style="rounded" fontcolor="#782b90" fontsize="25" penwidth="2" height=".6"]
    inventory [label="Inventory service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    rating [label="Rating service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    gatewaydb [label="MusicStore DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    client -> gateway
    gateway -> gatewaydb
    gateway -> rating
    gateway -> inventory
    {rank = same; gateway; gatewaydb;}
}
----

You will build the API Gateway for this microservices-based application.

NOTE: In a real-world application, the static content would often be served from a separate component.

=== Web Client

A _Single Page Application_ implemented with https://vuejs.org/[Vue.js] and https://www.apollographql.com/docs/react/[Apollo client].

=== Inventory Service

The _Inventory Service_ exposes product data over HTTP in JSON format:

* genres
* albums (name, artist, genre, ...etc)
* tracks

For the sake of simplicity, inventory data is loaded on startup from text files and stored into memory.

=== Rating Service

The _Rating Service_ receives customers' reviews on albums:

* customer name
* rating
* comment

It exposes this data over HTTP in JSON format.
It can also compute an average rating for an album.

Again, for simplicity, reviews are stored only in memory.

== Getting started

=== Prerequisites

==== Java Development Kit

JDK 8 or later must be installed on our machine.
If you don't have it already, you can get one from:

* https://adoptopenjdk.net, or
* https://www.oracle.com/technetwork/java/javase/downloads/index.html

You can use either OpenJDK or Oracle JDK.

==== Maven

Download Apache Maven from https://maven.apache.org/download.cgi.

Extract the archive contents to a directory of your choice and add it to the `PATH`.

==== IDE

It is recommended to use an IDE. It does not matter if it's IntelliJ, Eclipse or Netbeans.

If you donâ€™t have an IDE, follow these instructions to get started with Eclipse:

* browse to the https://www.eclipse.org/downloads/packages/[Eclipse downloads page]
* select the _Eclipse IDE for Java Developers_ package and download it
* extract the archive contents to a directory of your choice
* in the destination directory, execute the Eclipse binary
* create a workspace

==== Postgres database

If you have Docker running on your machine, you can start the Postgres database in a container:

[source,shell]
.Starting a Postgres Database with Docker
----
docker run -p 5432:5432 -e POSTGRES_USER=musicstore -e POSTGRES_PASSWORD=musicstore -d postgres
----

TIP: Linux and Mac users can simply execute the `run-postgres.sh` script after having imported the code in the next step.

Otherwise:

* download Postgres from https://www.postgresql.org/download/ and follow the instructions for your machine type
* create a `musicstore` database
* create a `musicstore` user with password `musicstore`
* grant the `musicstore` user with the permission to create tables on the the `musicstore` database

As a _superuser_ you could run these queries:

[source,sql]
----
CREATE DATABASE musicstore;
CREATE USER musicstore WITH ENCRYPTED PASSWORD 'musicstore';
GRANT ALL PRIVILEGES ON DATABASE musicstore TO musicstore;
----

=== Importing the code

The project code is hosted on GitHub.
Open a terminal in the directory of your choice and type:

[source,shell]
----
git clone https://github.com/tsegismont/graphql-api-gateway-workshop.git
----

Alternatively, you may download the https://codeload.github.com/tsegismont/graphql-api-gateway-workshop/zip/master[project archive] from GitHub and extract the content.

Inside the project directory, run Maven to build the project:

[source,shell]
----
mvn install
----

Now open the IDE and import the project.

In Eclipse:

* click on _File_ > _Import_
* select _Maven_ > _Existing Maven Projects_
* in _Root Directory_, type the project directory path or select it with the _Browse..._ button
* make sure the root project and all sub-projects checkboxes are ticked and click _Finish_

In IntelliJ:

* click on _File_ > _New_ > _Project from Existing Sources_
* select the `pom.xml` file at the root of the project directory path and click _OK_
* click _Next_ on the following wizard panels and then _Finish_

=== Running backend services

IMPORTANT: Make sure you have built the project beforehand and started the Postgres database.

==== Inventory

Open a terminal at the root of the project directory and type:

[source,shell]
----
cd inventory
./run.sh
----

On Windows, open the file explorer in the `inventory` directory and execute `run.bat`.

==== Rating

Open a terminal at the root of the project directory and type:

[source,shell]
----
cd rating
./run.sh
----

On Windows, open the file explorer in the `rating` directory and execute `run.bat`.
