= Implementing the API Gateway pattern with GraphQL
Vladimir Dejanovic <https://twitter.com/vladimird_42[@vladimird_42]>; Thomas Segismont <https://twitter.com/tsegismont[@tsegismont]>
:toc: left
:toclevels: 3
:source-highlighter: rouge

== Introduction

=== Microservices architecture

In a https://microservices.io/patterns/microservices.html[microservices architecture], several loosely coupled, independently deployable services comprise a large software application.

This type of design can provide quite a few benefits, including:

* ability to release more often and more reliably
* codebases easier to reason about
* independence to a particular technology

For example, an online store application could be composed of, among others, an inventory and a rating service:

[graphviz, microservices-architecture, svg]
.Online store application, microservices architecture
----
strict digraph {
    rankdir=LR;
    splines="line";
    client [label="Client" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    inventory [label="Inventory service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    rating [label="Rating service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    inventorydb [label="Inventory DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    ratingdb [label="Rating DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    client -> inventory
    client -> rating
    inventory -> inventorydb
    rating -> ratingdb
}
----

=== The API Gateway pattern

The client side of the application may have to contact several services to display a single screen or page.
For instance, to display a product details page, it needs product info from the inventory service and customer reviews from the rating service.

But each network communication comes with a cost.
This applies to desktop browsers with DSL or fiber links, but the impact is particularly significant on mobile networks.

This is one important reason why the _API Gateway_ pattern has emerged.
In practice, the client communicates with a single service, the gateway, which communicates with the backend services:

[graphviz, api-gateway-pattern, svg]
.API Gateway pattern
----
strict digraph {
    rankdir=LR;
    splines="line";
    client [label="Client" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    gateway [label="API Gateway" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    inventory [label="Inventory service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    rating [label="Rating service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    gatewaydb [label="Gateway DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    inventorydb [label="Inventory DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    ratingdb [label="Rating DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    client -> gateway
    gateway -> gatewaydb
    gateway -> rating
    gateway -> inventory
    inventory -> inventorydb
    rating -> ratingdb
    {rank = same; gateway; gatewaydb;}
}
----

[NOTE]
====
The API Gateway does not eliminate the coordination required to make sense of the backend data.
In fact, it adds a new network hop in the the sequence of service calls.

But it moves most of the interactions inside the datacenter, where network latencies are considerably better.
====

Very often, the API Gateway implements cross-cutting concerns like security.
For example, it could generate a token after authenticating the client and communicate it to the backend services as a proof of identity.

Also, it may provide its own features, if they are only relevant to the frontend.
An e-commerce application, for instance, could manage customers' shopping carts at the API Gateway level.

=== Serving many clients

A lot of applications nowadays must be available from a wide range of clients: browsers, smartphones, tablets, wearables... etc.
These clients all have different capabilities in terms of display and networking.

Let's consider the product details use case.
For a desktop user, it makes sense to show:

* the product info (inventory service)
* the average rating (rating service)
* users' reviews (rating service)

However, in a smartphone app the reviews would probably be accessible in a separate view because of the screen size and shape.

But if the mobile developer uses the same endpoint as the web developer, the API Gateway wastes:

* time (_latency_) waiting for rating service responses, and
* bandwith sending a lot of unnecessary data.

To overcome this problem, it is possible to create a backend specific to each type of frontend.

[graphviz,backend-for-frontends,svg]
.Backend for Frontends pattern
----
strict digraph {
    rankdir=LR;
    splines="line";
    webclient [label="Web Client" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    mobileclient [label="Mobile Client" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    webgateway [label="Web Gateway" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    mobilegateway [label="Mobile Gateway" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    inventory [label="Inventory service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    rating [label="Rating service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    inventorydb [label="Inventory DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    ratingdb [label="Rating DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    webclient -> webgateway
    mobileclient -> mobilegateway
    webgateway -> rating
    webgateway -> inventory
    mobilegateway -> rating
    mobilegateway -> inventory
    inventory -> inventorydb
    rating -> ratingdb
    {rank = clients; mobileclient; webclient;}
    {rank = gateways; mobilegateway; webgateway;}
}
----

Nevertheless, this design, also known as the _Backend for Frontends_ pattern, has a few drawbacks:

* each specific API Gateway is another component to maintain
* a lot of code is duplicated
* each new feature has to be supported in all gateways before all clients can start using it

=== GraphQL in a nutshell

==== What it is

https://graphql.org/[GraphQL] is a query and schema definition language for your backend services.

It allows backend developers to describe the data in a language-agnostic fashion:

[source,graphql]
.GraphQL Schema file
----
type Genre {
  id: ID
  name: String!
}

type Album {
  id: ID
  name: String!
  genre: Genre!
  artist: String!
  reviews: [Review!]
}

type Review {
  name: String!
  rating: Int!
  comment: String
}

type Query {
  albums(genre: ID): [Album!]
}

schema {
  query: Query
}
----

And then frontend developers to request exactly the information they need:

[source,graphql]
.GraphQL query
----
query ($id: ID!) {
  album(id: $id) {
    id
    name
    genre {
      name
    }
    artist
  }
}
----

Which, given an `id` variable, would result in:

[source,json]
.GraphQL results
----
{
  "album": {
    "name": "Revolver",
    "genre": {
      "name": "Pop"
    },
    "artist": "The Beatles"
  }
}
----

While the https://graphql.github.io/graphql-spec/[GraphQL specification] does not prescribe any transport, in practice it's often used over HTTP and Websockets.

TIP: You will find a GraphQL schema definition and query authoring introduction on https://graphql.org/learn/.

==== How it works

When a GraphQL server runtime starts, it:

. parses the schema file to discover types and fields
. binds each field to data fetching functions

[graphviz,graphql-server-runtime,svg]
.GraphQL server runtime creation
----
strict digraph {
    splines="line";
    schema [label="Types and Fields" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    fetchers [label="Data Fetchers" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    runtime [label="GraphQL Runtime" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    schema -> runtime
    fetchers -> runtime
}
----

Then when a request is received, it:

. validates the query
. invokes each data fetching function needed to produce the result
. sends the result to the client

[graphviz,graphql-query-execution,svg]
.GraphQL query execution phases
----
strict digraph {
    rankdir=LR;
    splines="line";
    validation [label="Validation" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    execution [label="Execution" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    result [label="Result" shape="ellipse" color="#585858" style="filled" fillcolor="#782b90" fontcolor="white"]
    validation -> execution
    execution -> result
}
----

==== API Gateway engine

GraphQL becomes more and more popular, including as a replacement for _RESTful_ or HTTP/JSON APis.

But it particularly shines when building API Gateways.
Why?
Let's consider the product details use case again.

When the desktop client sends a request to the GraphQL runtime, it will ask for product info as well as users' review.
And the runtime will execute the corresponding data fetchers:

[source,graphql]
.Desktop client query
----
query ($id: ID!) {
  album(id: $id) {
    id
    name
    genre {
      name
    }
    artist
    reviews {
      name
      comment
      rating
    }
  }
}
----

However, the smartphone client will only ask for the product info:

[source,graphql]
.Smartphone client query
----
query ($id: ID!) {
  album(id: $id) {
    id
    name
    genre {
      name
    }
    artist
  }
}
----

And the runtime will **NOT** execute the data fetchers for users' reviews and, obviously, will not send the unnecessary data.

== What you will build

You will build a gateway for a music store microservices-based application.

=== The MusicStore Application

== Getting started

=== Prerequisites

==== Java Development Kit

JDK 8 or later must be installed on our machine.
If you don't have it already, you can get one from:

* https://adoptopenjdk.net, or
* https://www.oracle.com/technetwork/java/javase/downloads/index.html

You can use either OpenJDK or Oracle JDK.

==== Maven

Download Apache Maven from https://maven.apache.org/download.cgi.

Extract the archive contents to a directory of your choice and add it to the `PATH`.

==== IDE

It is recommended to use an IDE. It does not matter if it's IntelliJ, Eclipse or Netbeans.

If you donâ€™t have an IDE, follow these instructions to get started with Eclipse:

* browse to the https://www.eclipse.org/downloads/packages/[Eclipse downloads page]
* select the _Eclipse IDE for Java Developers_ package and download it
* extract the archive contents to a directory of your choice
* in the destination directory, execute the Eclipse binary
* create a workspace

==== Postgres database

If you have Docker running on your machine, you can start the Postgres database in a container:

[source,shell]
.Starting a Postgres Database with Docker
----
docker run -p 5432:5432 -e POSTGRES_USER=musicstore -e POSTGRES_PASSWORD=musicstore -d postgres
----

TIP: Linux and Mac users can simply execute the `run-postgres.sh` script after having imported the code in the next step.

Otherwise, browse to https://www.postgresql.org/download/ and follow the instructions for your machine type.

=== Getting the code

The project code is hosted on GitHub.
Open a terminal in the directory of your choice and type:

[source,shell]
----
git clone https://github.com/tsegismont/graphql-api-gateway-workshop.git
----

Alternatively, you may download the https://codeload.github.com/tsegismont/graphql-api-gateway-workshop/zip/master[project archive] from GitHub and extract the content.

Inside the project directory, run Maven to build the project:

[source,shell]
----
mvn install
----

Now open the IDE and import the project.

In Eclipse:

* click on _File_ > _Import_
* select _Maven_ > _Existing Maven Projects_
* in _Root Directory_, type the project directory path or select it with the _Browse..._ button
* make sure the root project and all sub-projects checkboxes are ticked and click _Finish_

In IntelliJ:

* click on _File_ > _New_ > _Project from Existing Sources_
* select the `pom.xml` file at the root of the project directory path and click _OK_
* click _Next_ on the following wizard panels and then _Finish_
